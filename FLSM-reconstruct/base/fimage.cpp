#include "fimage.h"
#include <opencv2/imgcodecs.hpp>
#include <iostream>

using namespace cv;
using namespace std;
using namespace flsm;

Mat flsmImread(const std::string &filename,int flags=-1){
    //only for 16bit tiff images generated by FastLSM
    const static unsigned short FLSM_TAG=65281;

    FILE *fp=fopen(filename.c_str(),"rb");if(fp==NULL){return Mat();}
    int byteOrder,ifdOffset;fread(&byteOrder,1,4,fp);fread(&ifdOffset,1,4,fp);
    int imageSize=(ifdOffset-8)/2;Mat m;

    unsigned short *datas=NULL;bool bEmpty=(imageSize<=0);
    if(!bEmpty){
        datas=new unsigned short[imageSize];fread(datas,1,imageSize*2,fp);
        fseek(fp,ifdOffset+10,SEEK_SET);int w;fread(&w,1,4,fp);
        m=Mat(imageSize/w,w,CV_16UC1,datas).clone();delete datas;
    }
    int flsmVersion=0;

    fseek(fp,ifdOffset+61*2,SEEK_SET);Mat wrapImage;
    unsigned short flsmtag;fread(&flsmtag,1,2,fp);
    if(flsmtag==FLSM_TAG){
        fseek(fp,ifdOffset+65*2,SEEK_SET);fread(&flsmVersion,1,4,fp);

        unsigned short wrapWidth,wrapHeight,left,top;
        fread(&wrapHeight,1,2,fp);fread(&wrapWidth,1,2,fp);
        wrapImage=Mat::zeros(wrapHeight,wrapWidth,m.type());

        if(!bEmpty){
            fread(&left,1,2,fp);fread(&top,1,2,fp);
            m.copyTo(wrapImage(Rect(left,top,m.cols,m.rows)));
        }
        m=wrapImage;
    }
    fclose(fp);

    if(flags==0){m.convertTo(m,CV_8UC1,0.00389);}
    else m.convertTo(m, CV_16UC1);
    return m;
}

Image::Image(string file, Mat imgData, cv::Rect roi_)
{
    fileName = file;
    data = imgData;
    posX = 0;
    posY = 0;
    roi = roi_;
}

bool Image::load(bool isOrigin)
{
    if(isLoaded()) return 0;
    if(isOrigin) data = flsmImread(fileName, -1);
    else
        data = imread(fileName, cv::IMREAD_ANYDEPTH);

    if(!isLoaded()){
        loadError = 1;
        if(isOrigin) {
            data = Mat::zeros(Size(roi.width, roi.height), CV_16UC1);
        }
        cerr << "Fail to read " << fileName << endl;
        return 1;
    }

    if(roi.width == 0)
        roi = Rect(0, 0, data.cols, data.rows);
    else
        data = data(roi).clone();
    if(flipcode != 0)
        flip(data, data, flipcode - 1);
    loadError = 0;
    return 0;
}

int Image::save()
{
    if(isLoaded()){
        bool wr;
//#pragma omp critical(storage)
        {
            wr = imwrite(fileName, data);
        }
        if(!wr){
            cerr << "Fail to write " << fileName << endl;
            return 1;
        }
    }
    return 0;
}

void Image::release(bool isOrigin)
{
    //if(isOrigin) fastImRelease(data);
    //else data.release();
    data.release();
}

bool Image::isLoaded()
{
    if(data.empty() || loadError != 0) return false;
    return true;
}

Image::~Image()
{
    release();
}
